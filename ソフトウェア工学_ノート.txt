ソフトウェアライフサイクル　資料22ページ　151ページ
  ウォーターフォールモデル→水が流れていくようにライフサイクルが進んでいく（実際はどこかでステップが戻ることが殆どである）
　　　　　スパイラルモデル→領域が極座標のように分けられ、その面をらせん状の線を描くように段階が進んでいく

手続型言語：代入処理が特徴
関数型言語：関数による再起処理が特徴

構文論：プログラミング言語の文法に基づいた正しいプログラムの書き方や形式　変数宣言、入出力文、代入文などのエラーにならない書き方
意味論：プログラムの実行・効果、値をどう求めるか　識別子（変数）x,y,z：整数型の宣言場所

変数の意味：データを表現し保持する。メモリ上のある領域にある識別子
　→型を宣言するのは、領域を確保することを表す

記憶領域の静的な割付け：コンパイル時に固定した領域の割当
　　　　　動的な割付け：プログラム実行中に動的に割当て・変更
			ポインタが識別子と記憶領域（ヒープ）の対応を与える
			未使用領域を示すための特別な識別子（U）
			アロケータ（割当てプログラム）、ガベージ・コレクタ（不要領域ブロックの識別・再利用）

サブルーチンの呼び出し
　参照呼出し：引数領域へのポインタを手続きへ渡す
　値呼び出し：引数の値が関数に引き渡される
　再起呼び出しの実現：スタックを用いる

　再起と繰り返し
　fact(0) = 1  fact(n) = n * f(n-1)
  foo(0, m) = m  foo(n,m) = f(n-1, n*m)
　再起の方が処理に時間がかかる

文脈自由文法

形式的な方法
　表示的意味(denotational semantics) 数学的
  操作的意味(operational semantics)　機械などの操作
  公理的意味(axiomatic semantics)　　論理式的

記号列Eの意味は意味関数Mで与えられる
　M:構文領域→解釈領域
    　記号列→値

2+3 → M〚2+3〛 = 5
1+4 → M〚1+4〛 = 5

M〚x:=e〛(s) 代入する前のメモリの状態（s）を受け取り、代入した後のメモリの状態を返す写像

プログラムの意味関数M
プログラム→[変数の状態→変数の状態]
M〚P〛(s_0)=s_1

例
P1: x:=0 y:=1
P2: x:=x+1; y:=x+y

M〚P1〛(x,y) ＝ (0,1)
M〚P2〛(x,y) = (x+1, x+1+y)
M〚P〛(s_0(0,0)) = s_4(1,2)

代入文の意味
M〚x:=e〛(s) = a[ x, val[e](s) ](s)
  val[e](s)  : 状態sにおける式eの値
  a[x,α](s) : 状態sにおける変数xの値をαとする

複合文
M〚P1;P2〛(s) = M〚P2〛(M〚P1〛(s))

read x;
If x=0 then x:=1; i:=x-1;
While I>=2 do
	x:=x*I; i:=i-1;
write x;

M[[I:=x-1]](M[[if x=0 then x:=1]](x, i)) = [i:=x-1](if x=0 then (1, i) else (x, i)) = if x=0 then (1, 0) else (x, x-1)
/33/3//
F(x, i) = if i>=2 then F([x := x*i; i *= i-1](x, i)) else (x, i) = if i>=2 then F(x*i, i-1) else (x, i)

solution[y | y(s) = if I>=2 then y( M[[ x:=x*I; I:=I-1]](s) ) else s]

[[Q]](x, i) = if x=0 then (1, 0) else f(x, x-1)
累積用変数をもつ繰り返し：末尾再帰

操作的意味
抽象的な機械を定めて、プログラムの実行に伴う機械の状態変化を定義して、プログラムの意味を与える

操作

書き換え規則：等式を完全に判定できる規則の塊
　　必ず含まれる要素が減少するため、等式の判定は停止する、という性質を持つ
例
WB  -> B
BS   -> W
WW -> W

BSBBS = BWW
BSBBS = WBBS = BBS = BW
BWW = BWよって、この等式は正しい。 
 

公理的意味(axiomatic semantics)
表明付きプログラム　{α}P{β}
前提条件αが成立している状態で、プログラムPを実行した時、実行後に帰結βが成立（部分正当性）

α：前提条件
プログラムの実行前、満足すべき条件

β：帰結
実行後、満足すべき条件

{α}P{β}：表明付きプログラム（検証文）
プログラムPは表明（仕様）{α}・・・{β}を満たす

完全正当性：部分正当性＋停止性
停止性：αが成立している時Pを実行すると、実行は停止

代入文の公理：{α(e)}x := e {α(x)}
α(e) : 論理式　ex. e+1=7
     E : 項(式)　ex. 2*3+1

例：x := 10の実行後は、x＞2が成立している
　{10 > 2} x := 10 {x > 2}

{n > 0} x := n {x > 0} ->成り立つ
{x > 0} x := n {n > 0} ->成り立たない

複合文
{α}P1{β}  {β}P2{γ}
　　　{α}P {γ}
前提1 前提２/結論　の形式

条件文
If Q then P1 else P2

{α^Q}P1{β}  {α^bar Q}P2{β}
{α}if Q then P1 else P2{β}

繰り返し文
While Q do P

	{α^Q} P {α}
{α}while Q do P{α^bar Q}

Whiile文が終了しているということは、前提条件が成り立たなくなったということ→bar Qになっている
α：ループ不変条件
条件αは必ず保たれる。物理の保存則のイメージ。

帰結の規則
α=>α1 {α1} P {β1}  β1=>β
       {α} P {β}

前提条件α1をαに強める
結論β1をベータに弱める
ベン図による変化のイメージ

